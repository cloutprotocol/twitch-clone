import { db } from "@/lib/db";

/**
 * Enhanced Thumbnail Service with LiveKit Egress Integration
 * 
 * Features:
 * - Automatic thumbnail generation via LiveKit Egress
 * - Smart caching with TTL and memory management
 * - Cloud storage integration for persistent thumbnails
 * - Fallback to manual/client-side generation
 * - CDN-ready URLs with cache busting
 */

// Simple thumbnail URL generation (most efficient)
export const getThumbnailUrl = (streamId: string, timestamp?: number) => {
  const ts = timestamp || Date.now();
  return `/api/thumbnail/${streamId}?t=${ts}`;
};

// Update thumbnail URL in database (called when stream goes live)
export const updateStreamThumbnail = async (streamId: string, thumbnailUrl: string) => {
  try {
    await db.stream.update({
      where: { id: streamId },
      data: { thumbnail: thumbnailUrl },
    });
  } catch (error) {
    console.error("Error updating stream thumbnail:", error);
  }
};

// Generate thumbnail from video frame (browser-based, efficient)
export const generateThumbnailFromVideo = (videoElement: HTMLVideoElement): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Canvas context not available'));
        return;
      }

      canvas.width = 320; // Small size for efficiency
      canvas.height = 180;
      
      ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
      
      canvas.toBlob((blob) => {
        if (blob) {
          const url = URL.createObjectURL(blob);
          resolve(url);
        } else {
          reject(new Error('Failed to generate thumbnail'));
        }
      }, 'image/jpeg', 0.8);
    } catch (error) {
      reject(error);
    }
  });
};

/**
 * Enhanced Multi-Level Caching Strategy
 */

// Memory cache for ultra-fast access
const thumbnailCache = new Map<string, { 
  url: string; 
  timestamp: number; 
  egressId?: string;
  isAutoGenerated: boolean;
}>();

const CACHE_DURATION = 2 * 60 * 1000; // 2 minutes for auto-generated
const MANUAL_CACHE_DURATION = 10 * 60 * 1000; // 10 minutes for manual uploads

export const getCachedThumbnail = (streamId: string): string | null => {
  const cached = thumbnailCache.get(streamId);
  if (!cached) return null;
  
  const maxAge = cached.isAutoGenerated ? CACHE_DURATION : MANUAL_CACHE_DURATION;
  if (Date.now() - cached.timestamp < maxAge) {
    return cached.url;
  }
  
  // Remove expired cache
  thumbnailCache.delete(streamId);
  return null;
};

export const setCachedThumbnail = (
  streamId: string, 
  url: string, 
  egressId?: string,
  isAutoGenerated = false
) => {
  thumbnailCache.set(streamId, { 
    url, 
    timestamp: Date.now(), 
    egressId,
    isAutoGenerated
  });
};

/**
 * Start automatic thumbnail generation when stream goes live
 * Server-side only function
 */
export const startAutoThumbnails = async (streamId: string, userId: string) => {
  // Only run on server side
  if (typeof window !== 'undefined') {
    console.warn('startAutoThumbnails called on client side');
    return null;
  }

  try {
    // Check if already generating thumbnails
    const existing = thumbnailCache.get(streamId);
    if (existing?.egressId) {
      console.log(`Thumbnails already generating for stream ${streamId}`);
      return existing.egressId;
    }

    // Dynamic import to avoid client-side issues
    const { startThumbnailGeneration } = await import("./egress-service");
    
    // Start LiveKit Egress thumbnail generation
    const egressInfo = await startThumbnailGeneration({
      roomName: userId, // LiveKit room is named by userId
      streamId,
      captureInterval: 30, // Every 30 seconds
      width: 1280,
      height: 720
    });

    // Cache the egress info
    setCachedThumbnail(
      streamId, 
      getThumbnailUrl(streamId), // Placeholder URL until first thumbnail generates
      egressInfo.egressId,
      true // isAutoGenerated
    );

    console.log(`Started auto thumbnails for stream ${streamId}, egress: ${egressInfo.egressId}`);
    return egressInfo.egressId;
    
  } catch (error) {
    console.error("Failed to start auto thumbnails:", error);
    throw error;
  }
};

/**
 * Stop automatic thumbnail generation when stream ends
 * Server-side only function
 */
export const stopAutoThumbnails = async (streamId: string) => {
  // Only run on server side
  if (typeof window !== 'undefined') {
    console.warn('stopAutoThumbnails called on client side');
    return;
  }

  try {
    const cached = thumbnailCache.get(streamId);
    if (cached?.egressId) {
      // Dynamic import to avoid client-side issues
      const { stopThumbnailGeneration } = await import("./egress-service");
      await stopThumbnailGeneration(cached.egressId);
      
      // Update cache to remove egress ID but keep last thumbnail
      setCachedThumbnail(streamId, cached.url, undefined, false);
      
      console.log(`Stopped auto thumbnails for stream ${streamId}`);
    }
  } catch (error) {
    console.error("Failed to stop auto thumbnails:", error);
  }
};

/**
 * Get the best available thumbnail with smart fallbacks
 * Server-side only function
 */
export const getBestThumbnail = async (streamId: string, isLive: boolean): Promise<string | null> => {
  // Only run on server side
  if (typeof window !== 'undefined') {
    console.warn('getBestThumbnail called on client side');
    return getThumbnailUrl(streamId);
  }

  // 1. Check memory cache first (fastest)
  const cached = getCachedThumbnail(streamId);
  if (cached) return cached;

  // 2. Check database for stored thumbnail
  try {
    const stream = await db.stream.findUnique({
      where: { id: streamId },
      select: { thumbnail: true }
    });
    
    if (stream?.thumbnail) {
      // Cache it for future requests
      setCachedThumbnail(streamId, stream.thumbnail);
      return stream.thumbnail;
    }
  } catch (error) {
    console.error("Failed to get thumbnail from database:", error);
  }

  // 3. For live streams, return API endpoint that will generate on-demand
  if (isLive) {
    const fallbackUrl = getThumbnailUrl(streamId);
    setCachedThumbnail(streamId, fallbackUrl);
    return fallbackUrl;
  }

  // 4. No thumbnail available
  return null;
};

// Enhanced cleanup with egress session management (server-side only)
if (typeof window === 'undefined') {
  setInterval(async () => {
    const now = Date.now();
    for (const [key, value] of Array.from(thumbnailCache.entries())) {
      const maxAge = value.isAutoGenerated ? CACHE_DURATION : MANUAL_CACHE_DURATION;
      if (now - value.timestamp > maxAge) {
        // Stop any active egress sessions for expired cache
        if (value.egressId) {
          try {
            const { stopThumbnailGeneration } = await import("./egress-service");
            await stopThumbnailGeneration(value.egressId);
          } catch (error) {
            console.error("Failed to stop egress session:", error);
          }
        }
        thumbnailCache.delete(key);
      }
    }
  }, Math.min(CACHE_DURATION, MANUAL_CACHE_DURATION));
}